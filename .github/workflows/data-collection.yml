name: Data Collection

# This workflow collects environmental data for Ontario.
#
# Usage:
#   1. Go to Actions > Data Collection > Run workflow
#   2. Select "collect" mode (default)
#   3. Check which data sources you want to collect
#   4. Click "Run workflow"
#
# By default, Williams Treaty Communities and Provincial Parks are selected.
# You can select additional data sources or deselect the defaults as needed.

on:
  workflow_dispatch:
    inputs:
      # Mode selection
      mode:
        description: 'ðŸŽ¯ Mode: Check status OR Collect data'
        required: true
        type: choice
        options:
          - collect
          - status-only
        default: collect
      # Data source selection
      williams_treaty_communities:
        description: 'â˜ Williams Treaty Communities (community points)'
        type: boolean
        default: true
      williams_treaty_boundaries:
        description: 'â˜ Williams Treaty Boundaries (territory polygon) [âœ“ EXISTS]'
        type: boolean
        default: false
      fire_perimeters:
        description: 'â˜ Fire Perimeters (historical 1976-2024)'
        type: boolean
        default: false
      provincial_parks:
        description: 'â˜ Provincial Parks (Ontario parks)'
        type: boolean
        default: true
      conservation_authorities:
        description: 'â˜ Conservation Authorities (CA boundaries)'
        type: boolean
        default: false
      inaturalist:
        description: 'â˜ iNaturalist (biodiversity observations)'
        type: boolean
        default: false
      satellite:
        description: 'â˜ Satellite Data (NDVI, land cover info)'
        type: boolean
        default: false
      # Options
      upload_artifacts:
        description: 'ðŸ“¦ Upload generated data as artifacts (30 days)'
        type: boolean
        default: true
      force_refresh:
        description: 'ðŸ”„ Force refresh (re-download existing data)'
        type: boolean
        default: false

jobs:
  check-status:
    name: Check Data Status
    runs-on: ubuntu-latest
    outputs:
      status: ${{ steps.check.outputs.status }}

    steps:
    - uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: "3.11"
        cache: 'pip'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -e ".[dev]"

    - name: Check existing data status
      id: check
      run: |
        python check_data_status.py

        echo "## ðŸ“Š Current Data Status" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "Status check completed before data collection." >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY

        if [ -f "data_status.json" ]; then
          echo "### Existing Data Files" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          cat data_status.json | python -m json.tool 2>/dev/null || cat data_status.json
          echo '```' >> $GITHUB_STEP_SUMMARY
        fi

  collect-data:
    name: Collect Selected Data
    needs: check-status
    if: github.event.inputs.mode == 'collect'
    runs-on: ubuntu-latest
    timeout-minutes: 60

    steps:
    - uses: actions/checkout@v4

    - name: Validate data source selection
      run: |
        # Check if at least one data source is selected
        selected_count=0
        [ "${{ github.event.inputs.williams_treaty_communities }}" == "true" ] && selected_count=$((selected_count + 1))
        [ "${{ github.event.inputs.williams_treaty_boundaries }}" == "true" ] && selected_count=$((selected_count + 1))
        [ "${{ github.event.inputs.fire_perimeters }}" == "true" ] && selected_count=$((selected_count + 1))
        [ "${{ github.event.inputs.provincial_parks }}" == "true" ] && selected_count=$((selected_count + 1))
        [ "${{ github.event.inputs.conservation_authorities }}" == "true" ] && selected_count=$((selected_count + 1))
        [ "${{ github.event.inputs.inaturalist }}" == "true" ] && selected_count=$((selected_count + 1))
        [ "${{ github.event.inputs.satellite }}" == "true" ] && selected_count=$((selected_count + 1))

        echo "Selected data sources: $selected_count"

        if [ $selected_count -eq 0 ]; then
          echo "::warning::No data sources selected! The workflow will run but won't collect any data."
          echo "::warning::Please select at least one data source checkbox in the workflow inputs."
          echo ""
          echo "## âš ï¸ No Data Sources Selected" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "You've run the workflow in **collect mode** but haven't selected any data sources!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Please re-run the workflow and check at least one data source checkbox:" >> $GITHUB_STEP_SUMMARY
          echo "- Williams Treaty Communities" >> $GITHUB_STEP_SUMMARY
          echo "- Williams Treaty Boundaries" >> $GITHUB_STEP_SUMMARY
          echo "- Fire Perimeters" >> $GITHUB_STEP_SUMMARY
          echo "- Provincial Parks" >> $GITHUB_STEP_SUMMARY
          echo "- Conservation Authorities" >> $GITHUB_STEP_SUMMARY
          echo "- iNaturalist" >> $GITHUB_STEP_SUMMARY
          echo "- Satellite Data" >> $GITHUB_STEP_SUMMARY
        else
          echo "âœ“ $selected_count data source(s) selected for collection"
        fi

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: "3.11"
        cache: 'pip'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -e ".[dev]"

    - name: Check before status
      run: |
        echo "=== DATA STATUS BEFORE COLLECTION ==="
        python check_data_status.py

    - name: Create selective collection script
      run: |
        cat > collect_selected_data.py << 'EOFPYTHON'
        #!/usr/bin/env python3
        import asyncio
        import json
        import os
        import sys
        from pathlib import Path
        from datetime import datetime

        from ontario_data import (
            WILLIAMS_TREATY_FIRST_NATIONS,
            CWFISClient,
            INaturalistClient,
            OntarioGeoHubClient,
            SatelliteDataClient,
            StatisticsCanadaWFSClient,
            validate_collection_results,
        )

        DATA_DIR = Path("data")
        OUTPUT_DIR = DATA_DIR / "processed"
        OUTPUT_DIR.mkdir(parents=True, exist_ok=True)

        # Ontario bounds
        ONTARIO_BOUNDS = (41.7, -95.2, 56.9, -74.3)
        WILLIAMS_TREATY_BOUNDS = (43.8, -80.2, 45.2, -78.0)

        # Read selections from environment
        SELECTED = {
            'williams_treaty_communities': os.getenv('COLLECT_WT_COMMUNITIES', 'false') == 'true',
            'williams_treaty_boundaries': os.getenv('COLLECT_WT_BOUNDARIES', 'false') == 'true',
            'fire_perimeters': os.getenv('COLLECT_FIRE', 'false') == 'true',
            'provincial_parks': os.getenv('COLLECT_PARKS', 'false') == 'true',
            'conservation_authorities': os.getenv('COLLECT_CA', 'false') == 'true',
            'inaturalist': os.getenv('COLLECT_INAT', 'false') == 'true',
            'satellite': os.getenv('COLLECT_SATELLITE', 'false') == 'true',
        }

        async def main():
            results = {"timestamp": datetime.now().isoformat(), "collected": {}}

            print("=" * 80)
            print("SELECTIVE DATA COLLECTION")
            print("=" * 80)
            print(f"\nSelected data sources: {sum(SELECTED.values())}")
            for name, selected in SELECTED.items():
                print(f"  {'âœ“' if selected else 'âœ—'} {name}")
            print()

            # Williams Treaty Communities
            if SELECTED['williams_treaty_communities'] or SELECTED['williams_treaty_boundaries']:
                print("\n[Williams Treaty Data]")
                try:
                    client = StatisticsCanadaWFSClient()

                    if SELECTED['williams_treaty_communities']:
                        print("Fetching community points...")
                        communities_gdf = client.create_williams_treaty_data()
                        output_file = OUTPUT_DIR / "communities" / "williams_treaty_communities.geojson"
                        output_file.parent.mkdir(parents=True, exist_ok=True)
                        communities_gdf.to_file(output_file, driver="GeoJSON")
                        print(f"  âœ“ Saved {len(communities_gdf)} communities to {output_file}")
                        results["collected"]["williams_treaty_communities"] = {
                            "status": "success", "count": len(communities_gdf), "file": str(output_file)
                        }

                    if SELECTED['williams_treaty_boundaries']:
                        print("Fetching treaty boundaries...")
                        try:
                            gdf = await client.get_reserve_boundaries(province="ON", first_nations=WILLIAMS_TREATY_FIRST_NATIONS, max_features=100)
                            if not gdf.empty:
                                output_file = OUTPUT_DIR / "boundaries" / "williams_treaty.geojson"
                                output_file.parent.mkdir(parents=True, exist_ok=True)
                                gdf.to_file(output_file, driver="GeoJSON")
                                print(f"  âœ“ Saved {len(gdf)} boundaries to {output_file}")
                                results["collected"]["williams_treaty_boundaries"] = {
                                    "status": "success", "count": len(gdf), "file": str(output_file)
                                }
                        except Exception as e:
                            print(f"  âœ— Could not fetch boundaries: {e}")
                            results["collected"]["williams_treaty_boundaries"] = {"status": "error", "error": str(e)}
                except Exception as e:
                    print(f"  âœ— Error: {e}")

            # Fire Perimeters
            if SELECTED['fire_perimeters']:
                print("\n[Fire Perimeters]")
                try:
                    client = CWFISClient()
                    print("Fetching fire perimeters (1976-2024)...")
                    fire_gdf = await client.get_fire_perimeters(bounds=ONTARIO_BOUNDS, start_year=1976, end_year=2024)
                    if not fire_gdf.empty:
                        output_file = OUTPUT_DIR / "fire_perimeters_1976_2024.geojson"
                        fire_gdf.to_file(output_file, driver="GeoJSON")
                        print(f"  âœ“ Saved {len(fire_gdf)} fire perimeters to {output_file}")
                        results["collected"]["fire_perimeters"] = {
                            "status": "success", "count": len(fire_gdf), "file": str(output_file)
                        }
                except Exception as e:
                    print(f"  âœ— Error: {e}")
                    results["collected"]["fire_perimeters"] = {"status": "error", "error": str(e)}

            # Provincial Parks
            if SELECTED['provincial_parks']:
                print("\n[Provincial Parks]")
                try:
                    client = OntarioGeoHubClient()
                    print("Fetching provincial parks...")
                    parks_gdf = await client.get_provincial_parks()
                    if not parks_gdf.empty:
                        output_file = OUTPUT_DIR / "provincial_parks.geojson"
                        parks_gdf.to_file(output_file, driver="GeoJSON")
                        print(f"  âœ“ Saved {len(parks_gdf)} parks to {output_file}")
                        results["collected"]["provincial_parks"] = {
                            "status": "success", "count": len(parks_gdf), "file": str(output_file)
                        }
                except Exception as e:
                    print(f"  âœ— Error: {e}")
                    results["collected"]["provincial_parks"] = {"status": "error", "error": str(e)}

            # Conservation Authorities
            if SELECTED['conservation_authorities']:
                print("\n[Conservation Authorities]")
                try:
                    client = OntarioGeoHubClient()
                    print("Fetching conservation authorities...")
                    ca_gdf = await client.get_conservation_authorities()
                    if not ca_gdf.empty:
                        output_file = OUTPUT_DIR / "conservation_authorities.geojson"
                        ca_gdf.to_file(output_file, driver="GeoJSON")
                        print(f"  âœ“ Saved {len(ca_gdf)} authorities to {output_file}")
                        results["collected"]["conservation_authorities"] = {
                            "status": "success", "count": len(ca_gdf), "file": str(output_file)
                        }
                except Exception as e:
                    print(f"  âœ— Error: {e}")
                    results["collected"]["conservation_authorities"] = {"status": "error", "error": str(e)}

            # iNaturalist
            if SELECTED['inaturalist']:
                print("\n[iNaturalist]")
                try:
                    client = INaturalistClient()
                    print("Fetching iNaturalist observations...")
                    observations = await client.fetch(bounds=WILLIAMS_TREATY_BOUNDS, quality_grade="research", max_results=1000)
                    if observations:
                        output_file = OUTPUT_DIR / "inaturalist_observations_2024.json"
                        with open(output_file, "w") as f:
                            json.dump(observations, f, indent=2)
                        print(f"  âœ“ Saved {len(observations)} observations to {output_file}")
                        results["collected"]["inaturalist"] = {
                            "status": "success", "count": len(observations), "file": str(output_file)
                        }
                except Exception as e:
                    print(f"  âœ— Error: {e}")
                    results["collected"]["inaturalist"] = {"status": "error", "error": str(e)}

            # Satellite
            if SELECTED['satellite']:
                print("\n[Satellite Data]")
                try:
                    client = SatelliteDataClient()
                    info = {"message": "Satellite data client initialized", "timestamp": datetime.now().isoformat()}
                    output_file = OUTPUT_DIR / "satellite_data_info.json"
                    with open(output_file, "w") as f:
                        json.dump(info, f, indent=2)
                    print(f"  âœ“ Saved satellite info to {output_file}")
                    results["collected"]["satellite"] = {"status": "success", "file": str(output_file)}
                except Exception as e:
                    print(f"  âœ— Error: {e}")
                    results["collected"]["satellite"] = {"status": "error", "error": str(e)}

            # Save results
            results_file = Path("collection_results.json")
            with open(results_file, "w") as f:
                json.dump(results, f, indent=2)

            print("\n" + "=" * 80)
            print(f"COLLECTION COMPLETE: {len(results['collected'])} sources processed")
            print("=" * 80)

            # Validate collection results
            print("\n" + "=" * 80)
            print("VALIDATING COLLECTION RESULTS")
            print("=" * 80)

            # Transform results to match expected format for validation
            validation_results = {
                "timestamp": results["timestamp"],
                "sources": results["collected"],
            }

            success, errors, warnings = validate_collection_results(validation_results)

            if errors:
                print("\nâŒ VALIDATION ERRORS:")
                for error in errors:
                    print(f"   â€¢ {error}")

            if warnings:
                print("\nâš ï¸  VALIDATION WARNINGS:")
                for warning in warnings:
                    print(f"   â€¢ {warning}")

            # Determine exit code
            # Check which sources were selected and if they succeeded
            selected_sources = {k: v for k, v in SELECTED.items() if v}
            critical_sources = ["williams_treaty_communities", "provincial_parks"]

            critical_failures = []
            for source_name in critical_sources:
                if SELECTED.get(source_name, False):  # If it was selected
                    if source_name not in results["collected"]:
                        critical_failures.append(f"{source_name}: Not collected")
                    elif results["collected"][source_name].get("status") != "success":
                        status = results["collected"][source_name].get("status", "unknown")
                        error = results["collected"][source_name].get("error", "No error message")
                        critical_failures.append(f"{source_name}: {status} - {error}")

            if critical_failures:
                print("\n" + "=" * 80)
                print("âŒ CRITICAL FAILURE")
                print("=" * 80)
                print("\nOne or more critical data sources failed:")
                for failure in critical_failures:
                    print(f"   â€¢ {failure}")
                return 1  # Critical failure
            elif errors:
                print("\n" + "=" * 80)
                print("âš ï¸  PARTIAL SUCCESS")
                print("=" * 80)
                print("\nSome non-critical sources failed, but critical ones succeeded.")
                return 2  # Partial success
            else:
                print("\n" + "=" * 80)
                print("âœ… SUCCESS")
                print("=" * 80)
                print("\nAll selected data sources collected and validated successfully!")
                return 0  # Success

        if __name__ == "__main__":
            exit_code = asyncio.run(main())
            sys.exit(exit_code)
        EOFPYTHON

        chmod +x collect_selected_data.py

    - name: Run selective data collection
      run: |
        set +e  # Don't exit immediately on error, we want to capture exit code
        python collect_selected_data.py
        exit_code=$?
        echo "Collection exit code: $exit_code"

        # Exit codes: 0 = success, 1 = critical failure, 2 = partial success
        if [ $exit_code -eq 1 ]; then
          echo "::error::Critical data collection failure"
          exit 1
        elif [ $exit_code -eq 2 ]; then
          echo "::warning::Partial success - some non-critical sources failed"
          exit 0  # Don't fail the workflow for partial success
        else
          echo "Data collection successful"
          exit 0
        fi
      env:
        COLLECT_WT_COMMUNITIES: ${{ github.event.inputs.williams_treaty_communities }}
        COLLECT_WT_BOUNDARIES: ${{ github.event.inputs.williams_treaty_boundaries }}
        COLLECT_FIRE: ${{ github.event.inputs.fire_perimeters }}
        COLLECT_PARKS: ${{ github.event.inputs.provincial_parks }}
        COLLECT_CA: ${{ github.event.inputs.conservation_authorities }}
        COLLECT_INAT: ${{ github.event.inputs.inaturalist }}
        COLLECT_SATELLITE: ${{ github.event.inputs.satellite }}
        EBIRD_API_KEY: ${{ secrets.EBIRD_API_KEY }}

    - name: Check after status
      if: always()
      run: |
        echo ""
        echo "=== DATA STATUS AFTER COLLECTION ==="
        set +e  # Don't fail on validation errors here
        python check_data_status.py
        exit_code=$?
        echo "Validation exit code: $exit_code"

        # Always output status, but show warnings/errors clearly
        if [ $exit_code -eq 1 ]; then
          echo "::error::Critical data validation failure after collection"
        elif [ $exit_code -eq 2 ]; then
          echo "::warning::Some data files have issues after collection"
        fi

        # Don't exit here - we want the summary step to run
        exit 0

    - name: Upload data artifacts
      # Upload artifacts even if there were partial failures (but not if job was cancelled)
      if: github.event.inputs.upload_artifacts == 'true' && !cancelled()
      uses: actions/upload-artifact@v4
      with:
        name: ontario-data-${{ github.run_number }}
        path: |
          data/processed/**/*.geojson
          data/processed/**/*.json
          data/processed/**/*.csv
          collection_results.json
          data_status.json
        retention-days: 30
        if-no-files-found: warn

    - name: Create collection summary
      if: always()
      run: |
        echo "## ðŸ“¦ Data Collection Results" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Run:** #${{ github.run_number }}" >> $GITHUB_STEP_SUMMARY
        echo "**Status:** ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
        echo "**Force Refresh:** ${{ github.event.inputs.force_refresh }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY

        echo "### Selected Data Sources" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "| Data Source | Selected |" >> $GITHUB_STEP_SUMMARY
        echo "|-------------|----------|" >> $GITHUB_STEP_SUMMARY
        echo "| Williams Treaty Communities | ${{ github.event.inputs.williams_treaty_communities == 'true' && 'âœ…' || 'â¬œ' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Williams Treaty Boundaries | ${{ github.event.inputs.williams_treaty_boundaries == 'true' && 'âœ…' || 'â¬œ' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Fire Perimeters | ${{ github.event.inputs.fire_perimeters == 'true' && 'âœ…' || 'â¬œ' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Provincial Parks | ${{ github.event.inputs.provincial_parks == 'true' && 'âœ…' || 'â¬œ' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Conservation Authorities | ${{ github.event.inputs.conservation_authorities == 'true' && 'âœ…' || 'â¬œ' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| iNaturalist | ${{ github.event.inputs.inaturalist == 'true' && 'âœ…' || 'â¬œ' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Satellite Data | ${{ github.event.inputs.satellite == 'true' && 'âœ…' || 'â¬œ' }} |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY

        if [ -f "collection_results.json" ]; then
          echo "### Collection Results" >> $GITHUB_STEP_SUMMARY
          echo '```json' >> $GITHUB_STEP_SUMMARY
          cat collection_results.json | python -m json.tool
          echo '```' >> $GITHUB_STEP_SUMMARY
        fi

        if [ -f "data_status.json" ]; then
          echo "### Final Data Status" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          python check_data_status.py 2>&1 | tail -20
          echo '```' >> $GITHUB_STEP_SUMMARY
        fi
